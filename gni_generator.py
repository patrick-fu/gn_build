#!/usr/bin/env python3
# Copyright 2021 ZEGO. All rights reserved.

import os
import sys
import argparse
from typing import List, Tuple

HELP = """
A helper tools for auto collect all source code files
recursively and generate a ".gni" file to list them.

You can run this script directly, or import "generate_gni"
function from other python script.
"""

DEFAULT_TYPE = ['h', 'c', 'cc', 'cpp', 'hpp', 'm', 'mm']

def generate_gni(root_path: str, proj_name: str, suffix: str, use_absolute_path=False, retain_dir_levels=0, include_file_type=DEFAULT_TYPE) -> Tuple[str, str]:
    """Recursive list files under root_path,
    and generate a .gni file which contains a
    list var names "${proj_name}{suffix}",
    and the gni file name is same as var

    Args:
        root_path (str): Folder path to be list
        proj_name (str): Deps's name
        suffix (str): GNI file and var suffix, e.g. "_headers"

        use_absolute_path (bool, optional): Whether generate full absolute path. Defaults to False.

        retain_dir_levels (int, optional): When 'use_absolute_path' if False, is there need to remain directory level, and how many levels needs to remain. Defaults to 0.

        include_file_type ([type], optional): What type of files need to be collected. Defaults to DEFAULT_TYPE.

    Returns:
        Tuple[str, str]: (gni file path, gni var name)
    """
    filelist: List[str] = []
    filelist_str = ''

    for root, _, files in os.walk(root_path):
        for name in files:
            if name.split('.')[-1] not in include_file_type:
                continue
            # Only collect specific type files
            filelist.append(os.path.join(root, name))

    filelist.sort()
    for f in filelist:
        if not use_absolute_path:
            split_path = root_path.split(os.sep)
            if retain_dir_levels > 0:
                split_path = split_path[:-retain_dir_levels]
            prefix_path_to_remove = os.sep.join(split_path)
            f = f[len(prefix_path_to_remove):].lstrip(os.sep)
        file_str = '  "{}",\n'.format(f)
        filelist_str += file_str

    gni_var_name = '{0}{1}'.format(proj_name, suffix)
    gni_content = '# WARNING: DO NOT EDIT MANUALLY!\n# GENERATED BY "gni_generator.py"\n'
    gni_content += '\n{0} = [\n{1}]\n'.format(gni_var_name, filelist_str)
    gni_file_path = os.path.join(root_path, gni_var_name+'.gni')

    with open(gni_file_path, 'w') as fw:
        fw.write(gni_content)

    return (gni_file_path, gni_var_name)

def main(argv):
    parser = argparse.ArgumentParser(description=HELP)
    parser.add_argument('root_path', type=str, help='The root sources path to perform generating GNI.')
    parser.add_argument('proj_name', type=str, help='The project or module name for the root path dir.')
    parser.add_argument('--suffix', '-s', type=str, default='', help='GNI file and var suffix, e.g. "_headers", default to empyt string.')
    parser.add_argument('--absolute', '-a', default=False, action='store_true', help='Whether generate full absolute path. Defaults to False.')
    parser.add_argument('--retain-level', '-r', type=int, default=0, help='When "absolute (-a, use_absolute_path)" if False, is there need to remain directory level, and how many levels needs to remain. Defaults to 0.')
    parser.add_argument('--include-type', action='store', type=str, nargs='+', choices=DEFAULT_TYPE, default=DEFAULT_TYPE, help='What type of files need to be collected. Defaults to DEFAULT_TYPE.')

    args = parser.parse_args(argv)

    file_path, var_name = generate_gni(
        args.root_path,
        args.proj_name,
        args.suffix,
        use_absolute_path=args.absolute,
        retain_dir_levels=args.retain_level,
        include_file_type=args.include_type
    )
    print('[Generate GNI] Ouput: "%s"' % file_path)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
